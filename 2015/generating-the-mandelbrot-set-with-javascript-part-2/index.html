<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Evan Hackett - Generating the Mandelbrot Set with Javascript - Part 2</title>
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="/feed.xml">
  <link rel="stylesheet" href="/assets/css/highlight.css">

  <!-- mathjax -->
  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- fontawesome -->
<script src="https://use.fontawesome.com/f92380e0dd.js"></script>
</head>
<body>

  <nav class="main-nav">
    
        <a href="/"> <span class="arrow">←</span> Home </a>
    

    
        
            <a href="/about">About </a>
        
    
    <a class="cta" href="/feed.xml">Subscribe</a>
</nav>


  

  <section id="wrapper" class="">
    <article class="post">
    <header>
        <h1>Generating the Mandelbrot Set with Javascript - Part 2</h1>
        <h2 class="headline">July 3, 2015</h2>
    </header>
    <section id="post-body">
        <p>Welcome to part 2 of “Generating the Mandelbrot Set with Javascript”. In <a href="/2015/generating-the-mandelbrot-set-with-javascript-part-1/">part 1</a> we learned about the Mandelbrot set equation, and what it’s pieces are. We learned about sets, the complex plane, and complex numbers. We still have a few math concepts to understand before we can fully comprehend what the Mandelbrot set actually is. After that, we will generate the graph using javascript and an HTML canvas!<!--more--></p>

<p>At the end of part 1, we were working on understanding this definition:</p>

<p>“… the set of values of c in the complex plane for which the orbit of 0 under iteration of the complex quadratic polynomial
<script type="math/tex">z_{n+1}=z_n^2+c</script> remains bounded.”</p>

<p>We should now have the vocabulary to understand the first half. Now lets tackle the second half:</p>

<p>“…for which the orbit of 0 under iteration of the complex quadratic polynomial <script type="math/tex">z_{n+1}=z_n^2+c</script> remains bounded.”</p>

<p><b>Complex quadratic polynomial</b> - A polynomial is simply an algebraic expression involving variables, coefficients, and arithmetic operations. Here are some examples:</p>

<p><script type="math/tex">x + 1</script><br />
<script type="math/tex">2x - 3</script><br />
<script type="math/tex">x^2 + 4</script><br />
<script type="math/tex">y^5 - 12</script></p>

<p>All of the above are polynomials. What makes a polynomial quadratic is when the degree of the highest exponent is 2. So the only quadratic polynomial in the example list I just gave would be <script type="math/tex">x^2 + 4</script>. That is because the highest exponent is equal to 2. A complex quadratic polynomial is simply a quadratic polynomial that has complex numbers as coefficients.</p>

<p><b>Orbit of 0 under iteration</b> - We have a function <script type="math/tex">f_{c}(z) = z^2 + c</script>. First, we choose a number for c. Lets start with 1. Now we are going to plug in 0, and “iterate” to infinity. So we plug in 0, get the output, and then we plug in that output into the function again. Then we take that output and plug it into the function again. We repeat this process to infinity.</p>

<p><script type="math/tex">f_{1}(0) = 0^2 + 1</script><br />
<script type="math/tex">f_{1}(1) = 1^2 + 1</script><br />
<script type="math/tex">f_{1}(2) = 2^2 + 1</script><br />
<script type="math/tex">f_{1}(5) = 5^2 + 1</script><br />
…</p>

<p>In the example above, I used a real number (1) for c to make it easier to see what is going on. C should be a complex number though.</p>

<p><b>Remains bounded</b> - Here is where it all comes together. A function is bounded if there exists a number, M, in which the set of all numbers in that functions range is less than M. To see if the orbit under iteration remains bounded, we keep iterating to infinity, and we check whether the outputs are “tending towards” infinity. If they are clearly going up to infinity, we consider it unbounded. If the outputs are clearly staying below infinity (growing too slowly, or alternating between numbers), than it IS bounded. In the example above, when we iterated f1 to infinity, the outputs were clearly just going to explode (grow quickly) and tend toward infinity. What if we chose -1 instead? Once again we start by plugging in 0:</p>

<p><script type="math/tex">f_{-1}(0) = 0^2 -1</script><br />
<script type="math/tex">f_{-1}(-1) = (-1)^2 -1</script><br />
<script type="math/tex">f_{-1}(0) = 0^2 -1</script><br />
<script type="math/tex">f_{-1}(-1) = (-1)^2 -1</script><br />
…</p>

<p>The outputs will clearly alternate back and forth forever. The outputs are not tending towards infinity (there exists a number, M, such that all the values of f-1 under iteration are less than M. This means f-1 remains bounded under iteration! -1 isn’t a complex number though, so it isn’t part of the Mandelbrot set even though it remains bounded.</p>

<p>Now, one last complication. We aren’t just looking at the outputs. We are looking at the magnitude of the complex number (the distance from 0 on the complex plane). So the complex number <script type="math/tex">3 + 4i</script> would have a magnitude of 5. To get the magnitude, you picture the complex number as a right triangle, and use the Pythagorean theorem. So for <script type="math/tex">3 + 4i</script>, picture a triangle with side lengths 3 and 4. The hypotenuse would be 5, because <script type="math/tex">3^2 + 4^2 = 5^2</script>.</p>

<p>That is a lot to take in! Lets take another look at the definition we are trying to understand.</p>

<p>“… the set of values of c in the complex plane for which the orbit of 0 under iteration of the complex quadratic polynomial <script type="math/tex">z_{n+1}=z_n^2+c</script> remains bounded.”</p>

<p>Ok, we got this. The Mandelbrot set is the set of all complex numbers whose magnitudes don’t tend toward infinity when you start at 0 and iterate through the function <script type="math/tex">f_{c}(z) = z^2 + C</script>.</p>

<p>That is pretty much it for the math and vocabulary. If you are still feeling a little lost, just keep reading, it will make a lot more sense when we code it up.</p>

<p>Ok, so it’s code time! If we are going to be drawing pictures, we need a canvas.</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;canvas</span> <span class="na">id=</span><span class="s">"canvas"</span> <span class="na">width=</span><span class="s">"800"</span> <span class="na">height=</span><span class="s">"800"</span><span class="nt">&gt;&lt;/canvas&gt;</span></code></pre></figure>

<p>Place that somewhere in the body of an html page. I’m going to go with 800 by 800 pixels, because that seems like a good place to start. Now we have a place to draw our graph. That is pretty much all we need as far as HTML goes.</p>

<p>Now it’s time to write some javascript. We will need to do the standard canvas setup stuff (get canvas, get context, get resolution, get offset).</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'canvas'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s1">'2d'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">RESOLUTION</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">LEFT_OFFSET</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">offsetLeft</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">TOP_OFFSET</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">offsetTop</span><span class="p">;</span></code></pre></figure>

<p>Now we can draw to the canvas. But first we need to figure out what what to draw, and where to draw it. Our drawing strategy will go like this:
Start at (0,0) and loop through every coordinate on the canvas.
Convert that cartesian coordinate to the corresponding complex number.
Check if that complex number is bounded
color the pixel according to the number of iterations it took to discover if the number was bounded</p>

<p>Step 4 is the interesting part. We can color/shade the pixel as a function of the number of iterations. If it took 5 iterations to discover the number was not bounded, we can color it black. If it took 100, we can color it grey. If it took 1000, we can color it white. This is what allows us to create beautiful, colorful, complex looking patterns. Here is our drawing function:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">RESOLUTION</span><span class="p">;</span> <span class="nx">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">c</span> <span class="o">&lt;</span> <span class="nx">RESOLUTION</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// convert from Cartesian coordinates to complex coordinates</span>
      <span class="kd">var</span> <span class="nx">complex</span> <span class="o">=</span> <span class="p">{</span><span class="na">r</span><span class="p">:</span> <span class="nx">c</span><span class="o">/</span><span class="nx">RESOLUTION</span><span class="p">,</span> <span class="na">i</span><span class="p">:</span> <span class="o">-</span><span class="nx">r</span><span class="o">/</span><span class="nx">RESOLUTION</span><span class="p">};</span>

      <span class="c1">// test the point and return number of iterations</span>
      <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">isBounded</span><span class="p">(</span><span class="nx">complex</span><span class="p">);</span>

      <span class="c1">// The RGB values of each coordinate are a function of the number of iterations</span>
      <span class="nx">canvas</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="s2">"rgb("</span><span class="o">+</span> <span class="nx">n</span> <span class="o">+</span><span class="s2">","</span><span class="o">+</span> <span class="nx">n</span> <span class="o">+</span><span class="s2">","</span><span class="o">+</span> <span class="nx">n</span> <span class="o">+</span><span class="s2">")"</span><span class="p">;</span>

      <span class="c1">// draw a 1 pixel by 1 pixel rectangle at position (c, r)</span>
      <span class="nx">canvas</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>So, once again, we loop through all the coordinates on our canvas, we check the number of iterations it takes to discover if the point was bounded, we set the color accordingly, and then we plot the point on our canvas.</p>

<p>How do we know when something is bounded or unbounded after only a certain number of iterations? Some badass mathematicians figured out that once the output of an iteration reaches 2 or more, the iterates will tend to infinity. If it stays below 2, it might be bounded. We will not iterate to infinity, since that would unfortunately require infinite time. So instead we pick a max number of iterations that we are satisfied with. It should be small enough to allow our program to run at a reasonable speed, but big enough to somewhat accurately determine if the point is bounded or not. The bigger the number, the more accuracy. The smaller than number, the more speed (since less iterations will be required for each point). So we iterate up to that number, checking to see if the magnitude of the complex number ever exceeds 2. If it does, we immediately break out of the iteration, because we know that since it exceeded 2 it must be unbounded. Lets take a look at the code.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// defines the max number of times we iterate for a given number</span>
<span class="kd">var</span> <span class="nx">MAX_ITERATIONS</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="c1">// returns the number of iterations it took to see if the number is bounded</span>
<span class="kd">var</span> <span class="nx">isBounded</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// we are simulating an imaginary number by using 2 js numbers (1 for the 'real' part, and 1 for the 'imaginary' part)</span>
  <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="p">{</span><span class="na">r</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">i</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">// m for Mandelbrot :)</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">MAX_ITERATIONS</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// fc(z) = z^2 + C</span>
    <span class="c1">// (a+bi)*(a+bi) = a^2 - b^2 + 2ab</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">r</span> <span class="o">=</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">r</span> <span class="o">*</span> <span class="nx">m</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">i</span> <span class="o">*</span> <span class="nx">m</span><span class="p">.</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">temp</span> <span class="o">*</span> <span class="nx">m</span><span class="p">.</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">i</span><span class="p">;</span>

    <span class="c1">// Pythagorean theorem. Calculating if distance from origin is greater than 2</span>
    <span class="c1">// if: a^2 + b^2 &gt; 2^2</span>
    <span class="c1">// since we are on the complex plane, 'a' is the real part, 'b' is the imaginary part</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">r</span> <span class="o">*</span> <span class="nx">m</span><span class="p">.</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">m</span><span class="p">.</span><span class="nx">i</span> <span class="o">*</span> <span class="nx">m</span><span class="p">.</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// number tends to infinity, return # of iterations</span>
        <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// number might be bounded, return # of iterations</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>We start by defining a global constant representing the max number of iterations for each point. I chose 1000 here, but feel free to experiment. Since we are looking at the behavior of 0 under iteration (whether it is bounded or not) of the polynomial  <script type="math/tex">f_{c}(z) = z^2 + c</script>, we start by plugging in 0 into the equation <script type="math/tex">f_{c}(z) = z^2 + c</script>, where c is the complex number we passed into the function. To iterate this process, we are using a for-loop that just loops MAX_ITERATIONS number of times, unless it breaks early. After each iteration of the equation (still inside the for-loop), we check the magnitude of the output. We use the pythagorean theorem to get the hypotenuse of the right triangle formed by the “length” and “width” (real and imaginary) part of the number. We then check if that number is greater than 2. If it is, we can immediately return, since we know the number is unbounded. Rather than simply returning true or false, we return the number of iterations. This is so we can color or shade the point as a function of the number of iterations. If the number’s magnitude never exceeded 2, we don’t break early. The for-loop will complete, and our function will return the MAX_ITERATIONS.</p>

<p>That’s it! We should now have a graph that looks something like this:</p>

<p><img src="/assets/images/mandelbrot-before-recenter.png" alt="Mandelbrot set screenshot" /></p>

<p>The origin (0,0) of our graph is at the upper left corner, and the point (1,1) is on the bottom right corner. If you want a more complete picture, you should try to get the origin in the center of the canvas, and you might need to zoom out a little. To do this, you will need to modify this line:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// convert from Cartesian coordinates to complex coordinates</span>
 <span class="kd">var</span> <span class="nx">complex</span> <span class="o">=</span> <span class="p">{</span><span class="na">r</span><span class="p">:</span> <span class="nx">c</span><span class="o">/</span><span class="nx">RESOLUTION</span><span class="p">,</span> <span class="na">i</span><span class="p">:</span> <span class="o">-</span><span class="nx">r</span><span class="o">/</span><span class="nx">RESOLUTION</span><span class="p">};</span></code></pre></figure>

<p>If you want to change the colors, try modifying this line:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">canvas</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="s2">"rgb("</span><span class="o">+</span> <span class="nx">n</span> <span class="o">+</span><span class="s2">","</span><span class="o">+</span> <span class="nx">n</span> <span class="o">+</span><span class="s2">","</span><span class="o">+</span> <span class="nx">n</span> <span class="o">+</span><span class="s2">")"</span><span class="p">;</span></code></pre></figure>

<p>I’ll leave this as an exercise to the reader. If you want extra credit points, add the ability to zoom in on wherever the user clicks.</p>

<p>Thank you for reading, I hope you enjoyed our dive into the innards of generating the Mandelbrot Set! Be sure to check out my Mandelbrot Set generator where you can zoom in anywhere the user clicks: <a href="http://evanhackett.com/MandelbrotSet/">here</a></p>


    </section>
</article>
<footer id="post-meta" class="clearfix">
    <a href="/">
        <img class="avatar" src="/assets/images/avatar.jpg">
        <div>
            <span class="dark">Evan Hackett</span>
            <span>My blog. Mainly programming stuff.</span>
        </div>
    </a>

    <section id="sharing">
        <a href="https://github.com/evanhackett"><img src="/assets/images/GitHub-Mark-32px.png" alt="github-logo" /></a>
<a href="mailto:evanwhackett@gmail.com"><i class="fa fa-envelope fa-2x" aria-hidden="true"></i></a>

    </section>
</footer>

<!-- Disqus comments -->


<!-- Archive post list -->


  </section>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXXX-X', 'auto');
    ga('send', 'pageview');
  </script>
</body>
</html>
